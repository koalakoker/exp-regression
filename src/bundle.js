(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
module.exports=[
{
  "x": 0,
  "y": 36.24380275
},
{
  "x": 1,
  "y": 37.50588744
},
{
  "x": 2,
  "y": 38.5642267
},
{
  "x": 3,
  "y": 40.02531772
},
{
  "x": 4,
  "y": 41.19126472
},
{
  "x": 5,
  "y": 42.28109497
},
{
  "x": 6,
  "y": 42.43015985
},
{
  "x": 7,
  "y": 43.5657051
},
{
  "x": 8,
  "y": 44.88630801
},
{
  "x": 9,
  "y": 44.97197597
},
{
  "x": 10,
  "y": 46.0948477
},
{
  "x": 11,
  "y": 46.68056112
},
{
  "x": 12,
  "y": 47.57304138
},
{
  "x": 13,
  "y": 47.77674772
},
{
  "x": 14,
  "y": 48.99579495
},
{
  "x": 15,
  "y": 49.40979405
},
{
  "x": 16,
  "y": 50.02827719
},
{
  "x": 17,
  "y": 50.45430071
},
{
  "x": 18,
  "y": 51.38022148
},
{
  "x": 19,
  "y": 51.50449956
},
{
  "x": 20,
  "y": 52.03202625
},
{
  "x": 21,
  "y": 52.56526571
},
{
  "x": 22,
  "y": 52.4773144
},
{
  "x": 23,
  "y": 52.64283272
},
{
  "x": 24,
  "y": 53.15966377
},
{
  "x": 25,
  "y": 53.83431597
},
{
  "x": 26,
  "y": 54.29803892
},
{
  "x": 27,
  "y": 54.46559585
},
{
  "x": 28,
  "y": 55.31570629
},
{
  "x": 29,
  "y": 55.06681051
},
{
  "x": 30,
  "y": 55.36405145
},
{
  "x": 31,
  "y": 55.90505647
},
{
  "x": 32,
  "y": 55.99602612
},
{
  "x": 33,
  "y": 56.00295635
},
{
  "x": 34,
  "y": 56.13928058
},
{
  "x": 35,
  "y": 56.30051868
},
{
  "x": 36,
  "y": 56.69278284
},
{
  "x": 37,
  "y": 56.52310568
},
{
  "x": 38,
  "y": 56.76208935
},
{
  "x": 39,
  "y": 57.09024699
},
{
  "x": 40,
  "y": 57.29580305
},
{
  "x": 41,
  "y": 57.24276484
},
{
  "x": 42,
  "y": 57.89945604
},
{
  "x": 43,
  "y": 57.57701732
},
{
  "x": 44,
  "y": 58.47361234
},
{
  "x": 45,
  "y": 58.01070312
},
{
  "x": 46,
  "y": 58.4573415
},
{
  "x": 47,
  "y": 58.18265075
},
{
  "x": 48,
  "y": 58.98399508
},
{
  "x": 49,
  "y": 59.02504374
},
{
  "x": 50,
  "y": 58.9244715
},
{
  "x": 51,
  "y": 59.16344637
},
{
  "x": 52,
  "y": 58.9585106
},
{
  "x": 53,
  "y": 58.95210961
},
{
  "x": 54,
  "y": 59.56098452
},
{
  "x": 55,
  "y": 59.46545639
},
{
  "x": 56,
  "y": 59.13276993
},
{
  "x": 57,
  "y": 59.8354163
},
{
  "x": 58,
  "y": 59.72808047
},
{
  "x": 59,
  "y": 59.96331049
},
{
  "x": 60,
  "y": 59.76617385
},
{
  "x": 61,
  "y": 59.83979426
},
{
  "x": 62,
  "y": 60.23423744
},
{
  "x": 63,
  "y": 59.749781
},
{
  "x": 64,
  "y": 60.17127258
},
{
  "x": 65,
  "y": 60.38033312
},
{
  "x": 66,
  "y": 59.57307333
},
{
  "x": 67,
  "y": 60.23788086
},
{
  "x": 68,
  "y": 60.0356606
},
{
  "x": 69,
  "y": 60.06674172
},
{
  "x": 70,
  "y": 60.38810597
},
{
  "x": 71,
  "y": 60.08235463
},
{
  "x": 72,
  "y": 59.75355669
},
{
  "x": 73,
  "y": 60.14028237
},
{
  "x": 74,
  "y": 60.14141714
},
{
  "x": 75,
  "y": 60.15701427
},
{
  "x": 76,
  "y": 60.39401106
},
{
  "x": 77,
  "y": 60.46237986
},
{
  "x": 78,
  "y": 60.23439546
},
{
  "x": 79,
  "y": 60.09511324
},
{
  "x": 80,
  "y": 60.29744616
},
{
  "x": 81,
  "y": 60.76871448
},
{
  "x": 82,
  "y": 60.54042893
},
{
  "x": 83,
  "y": 60.54513414
},
{
  "x": 84,
  "y": 60.92492474
},
{
  "x": 85,
  "y": 60.52188174
},
{
  "x": 86,
  "y": 60.74372018
},
{
  "x": 87,
  "y": 60.1184996
},
{
  "x": 88,
  "y": 60.72352515
},
{
  "x": 89,
  "y": 60.60954874
},
{
  "x": 90,
  "y": 61.01449177
},
{
  "x": 91,
  "y": 60.68021585
},
{
  "x": 92,
  "y": 60.82540582
},
{
  "x": 93,
  "y": 60.79938552
},
{
  "x": 94,
  "y": 61.02091729
},
{
  "x": 95,
  "y": 60.59145172
},
{
  "x": 96,
  "y": 60.30628179
},
{
  "x": 97,
  "y": 61.02518611
},
{
  "x": 98,
  "y": 60.31574208
},
{
  "x": 99,
  "y": 60.42038
},
{
  "x": 100,
  "y": 60.56108479
}
]
},{}],2:[function(require,module,exports){
'use strict';

const rational = require('./rational');
const merge = require('./merge');

/**
 * Pass a 2-dimensional array that will return a function accepting indices to access the matrix
 *
 * @param mat array that initializes the matrix
 * @returns function with the array initialized and access to method that perform operations on the matrix
 */
function matrix(mat) {
    if (!Array.isArray(mat)) {
        throw new Error('Input should be of type array');
    }
    let _matrix = function() {
        let args = (arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments));
        return read(mat, args);
    }
    return Object.assign(_matrix, _mat(mat));
}


/**
 * Private function that returns an object containing methods
 * that perform operations on the matrix
 *
 * @param mat array that initializes the matrix
 * @returns object of methods performing matrix operations
 */
function _mat(mat) {
    return {
        size: () => size(mat),
        add: (operand) => operate(mat, operand, addition),
        sub: (operand) => operate(mat, operand, subtraction),
        mul: (operand) => operate(mat, operand, multiplication),
        div: (operand) => operate(mat, operand, division),
        prod: (operand) => prod(mat, operand),
        trans: () => trans(mat),
        set: function() {
            let args = (arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments));
            return {
                to: (val) => replace(mat, val, args)
            }
        },
        det: () => determinant(mat),
        inv: () => invert(mat),
        merge: merge(mat),
        map: (func) => map(mat, func),
        equals: (operand) => equals(mat, operand),
    };
}

module.exports = matrix;


/**
 * Calculates the size of the array across each dimension
 *
 * @param mat input matrix that initialized the function
 * @returns size of the matrix as an array
 */
function size(mat) {
    let s = [];
    while (Array.isArray(mat)) {
        s.push(mat.length);
        mat = mat[0];
    }
    return s;
}


/**
 * Private function to calculate the dimensions of the matrix
 *
 * @param mat input matrix that initializes the function
 * @returns integer indicating the number of dimensions
 */
function dimensions(mat) {
    return size(mat).length;
}


/**
 * Outputs the original matrix or a particular element or a matrix that is part of the original
 *
 * @param mat input matrix that initializes the function
 * @param args indices to access one or more array elements
 * @returns array or single element
 */
function read(mat, args) {
    if (args.length === 0) {
        return mat;
    } else {
        return extract(mat, args);
    }
}


/**
 * Private function to extract a single element or a matrix that is part of the original
 *
 * @param mat input matrix that initializes the function
 * @param args indices to access one or more array elements
 * @returns array or single element
 */
function extract(mat, args) {
    let dim = dimensions(mat);
    for (let i = 0; i < dim; i++) {
        let d = args[i];
        if (d === undefined) {
            break;
        }
        if (Array.isArray(d)) {
            // if an element of args is an array, more extraction is needed
            mat = extractRange(mat, d, i);
        } else if (Number.isInteger(d)) {
            if (dimensions(mat) > 1 && i > 0) {
                mat = mat.map(function(elem) {
                    return [elem[d]];
                });
            } else {
                mat = mat[d];
            }
        }
    }
    return mat;
}


/**
 * Private function to extract a portion of the array based on the specified range
 *
 * @param mat input matrix that initialized the function
 * @param arg single argument containing the range specified as an array
 * @param ind the current index of the arguments while extracting the matrix
 * @returns array from the specified range
 */
function extractRange(mat, arg, ind) {
    if (!arg.length) {
        return mat;
    } else if (arg.length === 2) {
        let reverse = arg[0] > arg[1];
        let first = (!reverse) ? arg[0] : arg[1];
        let last = (!reverse) ? arg[1]: arg[0];
        if (dimensions(mat) > 1 && ind > 0) {
            return mat.map(function(elem) {
                if (reverse) {
                    return elem.slice(first, last+1).reverse();
                }
                return elem.slice(first, last+1);
            })
        } else {
            mat = mat.slice(first, last+1);
            return (reverse && mat.reverse()) || mat;
        }
    }
}


/**
 * Replaces the specified index in the matrix with the specified value
 *
 * @param mat input matrix that initialized the function
 * @param value specified value that replace current value at index or indices
 * @param args index or indices passed in arguments to initialized function
 * @returns replaced matrix
 */
function replace(mat, value, args) { //TODO: Clean this function up
    let result = clone(mat);
    let prev = args[0];
    let start = prev[0] || 0;
    let end = prev[1] && prev[1] + 1 || mat.length;
    if (!Array.isArray(prev) && args.length === 1) {
        result[prev].fill(value);
    } else if (args.length === 1) {
        for (let ind = start; ind < end; ind++) {
            result[ind].fill(value);
        }
    }
    for (let i = 1; i < args.length; i++) {
        let first = Array.isArray(args[i]) ? args[i][0] || 0 : args[i];
        let last = Array.isArray(args[i]) ? args[i][1] && args[i][1] + 1 || mat[0].length : args[i] + 1;
        if (!Array.isArray(prev)) {
            result[prev].fill(value, first, last);
        } else {
            for (let ind = start; ind < end; ind++) {
                result[ind].fill(value, first, last);
            }
        }
    }
    return result;
}


/**
 * Operates on two matrices of the same size
 *
 * @param mat input matrix that initialized the function
 * @param operand second matrix with which operation is performed
 * @param operation function performing the desired operation
 * @returns result of the operation
 */
function operate(mat, operand, operation) {
    let result = [];
    let op = operand();

    for (let i = 0; i < mat.length; i++) {
        let op1 = mat[i];
        let op2 = op[i];
        result.push(op1.map(function(elem, ind) {
            return operation(elem, op2[ind]);
        }));
    }

    return result;
}


/**
 * Finds the product of two matrices
 *
 * @param mat input matrix that initialized the function
 * @param operand second matrix with which operation is performed
 * @returns the product of the two matrices
 */
function prod(mat, operand) {
    let op1 = mat;
    let op2 = operand();
    let size1 = size(op1);
    let size2 = size(op2);
    let result = [];
    if (size1[1] === size2[0]) {
        for (let i = 0; i < size1[0]; i++) {
            result[i] = [];
            for (let j = 0; j < size2[1]; j++) {
                for (let k = 0; k < size1[1]; k++) {
                    if (result[i][j] === undefined) {
                        result[i][j] = 0;
                    }
                    result[i][j] += multiplication(op1[i][k], op2[k][j]);
                }
            }
        }
    }
    return result;
}


/**
 * Returns the transpose of a matrix, swaps rows with columns
 *
 * @param mat input matrix that initialized the function
 * @returns a matrix with rows and columns swapped from the original matrix
 */
function trans(mat) {
    let input = mat;
    let s = size(mat);
    let output = [];
    for (let i = 0; i < s[0]; i++) {
        for (let j = 0; j < s[1]; j++) {
            if (Array.isArray(output[j])) {
                output[j].push(input[i][j]);
            } else {
                output[j] = [input[i][j]];
            }
        }
    }
    return output;
}

/**
 * Private method to clone the matrix
 *
 * @param mat input matrix that initialized the function
 * @returns cloned matrix
 */
function clone(mat) {
    let result = [];
    for (let i = 0; i < mat.length; i++) {
        result.push(mat[i].slice(0));
    }
    return result;
}

/**
 * Performs addition
 *
 * @param op1 first operand
 * @param op2 second operand
 * @returns result
 */
function addition(op1, op2) {
    return op1 + op2;
}

/**
 * Performs subtraction
 *
 * @param op1 first operand
 * @param op2 second operand
 * @returns result
 */
function subtraction(op1, op2) {
    return op1 - op2;
}

/**
 * Performs multiplication
 *
 * @param op1 first operand
 * @param op2 second operand
 * @returns result
 */
function multiplication(op1, op2) {
    return op1 * op2;
}

/**
 * Performs division
 *
 * @param op1 first operand
 * @param op2 second operand
 * @returns result
 */
function division(op1, op2) {
    return op1/op2;
}


/**
 * Computes the determinant using row reduced echelon form
 * Works best if the elements are integers or rational numbers
 * The matrix must be a square
 *
 * @param mat input matrix that initialized the function
 * @returns determinant value as a number
 */
function determinant(mat) {
    let rationalized = rationalize(mat);
    let siz = size(mat);
    let det = rational(1);
    let sign = 1;

    for (let i = 0; i < siz[0] - 1; i++) {
        for (let j = i + 1; j < siz[0]; j++) {
            if (rationalized[j][i].num === 0) {
                continue;
            }
            if (rationalized[i][i].num === 0) {
                interchange(rationalized, i, j);
                sign = -sign;
                continue;
            }
            let temp = rationalized[j][i].div(rationalized[i][i]);
            temp = rational(Math.abs(temp.num), temp.den);
            if (Math.sign(rationalized[j][i].num) === Math.sign(rationalized[i][i].num)) {
                temp = rational(-temp.num, temp.den);
            }
            for (let k = 0; k < siz[1]; k++) {
                 rationalized[j][k] = temp.mul(rationalized[i][k]).add(rationalized[j][k]);
            }
        }
    }

    det = rationalized.reduce((prev, curr, index) => prev.mul(curr[index]), rational(1));

    return sign * det.num/det.den;
}

/**
 * Interchanges one row index with another on passed matrix
 *
 * @param mat input matrix
 * @param ind1 one of the row indices to exchange
 * @param ind2 one of the row indices to exchange
 */
function interchange(mat, ind1, ind2) {
    let temp = mat[ind1];
    mat[ind1] = mat[ind2];
    mat[ind2] = temp;
}

/**
 * Inverts the input square matrix using row reduction technique
 * Works best if the elements are integers or rational numbers
 * The matrix has to be a square and non-singular
 *
 * @param mat input matrix
 * @returns inverse of the input matrix
 */
function invert(mat) {
    let rationalized = rationalize(mat);
    let siz = size(mat);
    let result = rationalize(identity(siz[0]));

    // Row Reduction
    for (let i = 0; i < siz[0] - 1; i++) {
        if (rationalized[i][i].num === 0) {
            interchange(rationalized, i, i + 1);
            interchange(result, i, i + 1);
        }
        if (rationalized[i][i].num !== 1 || rationalized[i][i].den !== 1) {
            let factor = rational(rationalized[i][i].num, rationalized[i][i].den);
            for (let col = 0; col < siz[1]; col++) {
                rationalized[i][col] = rationalized[i][col].div(factor);
                result[i][col] = result[i][col].div(factor);
            }
        }
        for (let j = i + 1; j < siz[0]; j++) {
            if (rationalized[j][i].num === 0) {
                // skip as no row elimination is needed
                continue;
            }

            let temp = rational(-rationalized[j][i].num, rationalized[j][i].den);
            for (let k = 0; k < siz[1]; k++) {
                rationalized[j][k] = temp.mul(rationalized[i][k]).add(rationalized[j][k]);
                result[j][k] = temp.mul(result[i][k]).add(result[j][k]);
            }
        }
    }

    // Further reduction to convert rationalized to identity
    let last = siz[0] - 1;
    if (rationalized[last][last].num !== 1 || rationalized[last][last].den !== 1) {
        let factor = rational(rationalized[last][last].num, rationalized[last][last].den);
        for (let col = 0; col < siz[1]; col++) {
            rationalized[last][col] = rationalized[last][col].div(factor);
            result[last][col] = result[last][col].div(factor);
        }
    }

    for (let i = siz[0] - 1; i > 0; i--) {
        for (let j = i - 1; j >= 0; j--) {
            let temp = rational(-rationalized[j][i].num, rationalized[j][i].den);
            for (let k = 0; k < siz[1]; k++) {
                rationalized[j][k] = temp.mul(rationalized[i][k]).add(rationalized[j][k]);
                result[j][k] = temp.mul(result[i][k]).add(result[j][k]);
            }
        }
    }

    return derationalize(result);
}

/**
 * Applies a given function over the matrix, elementwise. Similar to Array.map()
 * The supplied function is provided 4 arguments:
 * the current element,
 * the row index,
 * the col index,
 * the matrix.
 *
 * @param mat input matrix
 * @returns matrix of same dimensions with values altered by the function.
 */
function map(mat, func) {
    const s = size(mat);
    const result = [];
    for (let i = 0; i < s[0]; i++) {
        if(Array.isArray(mat[i])) {
            result[i] = [];
            for (let j = 0; j < s[1]; j++) {
                result[i][j] = func(mat[i][j], [i, j], mat);
            }
        } else {
            result[i] = func(mat[i], [i, 0], mat);
        }
    }
    return result;
}

/**
 * Converts a matrix of numbers to all rational type objects
 *
 * @param mat input matrix
 * @returns matrix with elements of type rational
 */
function rationalize(mat) {
    let rationalized = [];
    mat.forEach((row, ind) => {
        rationalized.push(row.map((ele) => rational(ele)));
    });
    return rationalized;
}

/**
 * Converts a rationalized matrix to all numerical values
 *
 * @param mat input matrix
 * @returns matrix with numerical values
 */
function derationalize(mat) {
    let derationalized = [];
    mat.forEach((row, ind) => {
        derationalized.push(row.map((ele) => ele.num/ele.den));
    });
    return derationalized;
}

/**
 * Generates a square matrix of specified size all elements with same specified value
 *
 * @param size specified size
 * @param val specified value
 * @returns square matrix
 */
function generate(size, val) {
    let dim = 2;
    while (dim > 0) {
        var arr = [];
        for (var i = 0; i < size; i++) {
            if (Array.isArray(val)) {
                arr.push(Object.assign([], val));
            } else {
                arr.push(val);
            }
        }
        val = arr;
        dim -= 1;
    }
    return val;
}

/**
 * Generates an identity matrix of the specified size
 *
 * @param size specified size
 * @returns identity matrix
 */
function identity(size) {
    let result = generate(size, 0);
    result.forEach((row, index) => {
        row[index] = 1;
    });
    return result;
}

/**
 * Checks the equality of two matrices
 * @param mat input matrix
 * @param operand second matrix
 */
function equals(mat, operand) {
    let op1 = mat;
    let op2 = operand();
    let size1 = size(op1);
    let size2 = size(op2);

    if (!size1.every((val, ind) => val === size2[ind])) {
        return false;
    }

    return op1.every((val, ind1) => val.every((ele, ind2) => Math.abs(ele - op2[ind1][ind2]) < 1e-10));
}   

},{"./merge":3,"./rational":4}],3:[function(require,module,exports){
'use strict';

/**
 * Merges two matrices in all directions
 * 
 * @param {Array} base Base matrix on which merge is performed
 */
function merge(base) {
    return {
        top: (mergeData) => top(base, mergeData),
        bottom: (mergeData) => bottom(base, mergeData),
        left: (mergeData) => left(base, mergeData),
        right: (mergeData) => right(base, mergeData)
    }
}

module.exports = merge;

/**
 * Merges the base matrix with the incoming matrix in the top direction
 * @param {Array} base 
 * @param {Array} mergeData incoming matrix
 */
function top(base, mergeData) {
    let baseWidth = base[0].length || base.length;
    let mergeDataWidth = mergeData[mergeData.length - 1].length || mergeData.length;

    if (baseWidth !== mergeDataWidth) {
        return base;
    }

    if (!Array.isArray(base[0])) {
        base = [base];
    }

    if (!Array.isArray(mergeData[mergeData.length - 1])) {
        mergeData = [mergeData];
    }

    for (let row = mergeData.length - 1; row >= 0; row--) {
        base.unshift(mergeData[row].map((ele) => ele));
    }
    return base;
}

/**
 * Merges the base matrix with the incoming matrix in the bottom direction
 * @param {Array} base 
 * @param {Array} mergeData incoming matrix
 */
function bottom(base, mergeData) {
    let baseWidth = base[base.length - 1].length || base.length;
    let mergeDataWidth = mergeData[0].length || mergeData.length;
    if (baseWidth !== mergeDataWidth) {
        return base;
    }

    if (!Array.isArray(base[base.length - 1])) {
        base = [base];
    }

    if (!Array.isArray(mergeData[0])) {
        mergeData = [mergeData];
    }


    for (let row = 0; row < mergeData.length; row++) {
        base.push(mergeData[row].map((ele) => ele));
    }
    return base;
}

/**
 * Merges the base matrix with the incoming matrix in the left direction
 * @param {Array} base 
 * @param {Array} mergeData incoming matrix
 */
function left(base, mergeData) {
    let baseHeight = base.length;
    let mergeDataHeight = mergeData.length;
    if (!Array.isArray(base[0]) && !Array.isArray(mergeData[0])) {
        base.unshift.apply(base, mergeData);
        return base;
    }

    if (baseHeight !== mergeDataHeight) {
        return base;
    }

    for (let row = 0; row < baseHeight; row++) {
        base[row].unshift.apply(base[row], mergeData[row].map((ele) => ele));
    }
    return base;
}

/**
 * Merges the base matrix with the incoming matrix in the right direction
 * @param {Array} base 
 * @param {Array} mergeData incoming matrix
 */
function right(base, mergeData) {
    let baseHeight = base.length;
    let mergeDataHeight = mergeData.length;
    if (!Array.isArray(base[0]) && !Array.isArray(mergeData[0])) {
        base.push.apply(base, mergeData);
        return base;
    }

    if (baseHeight !== mergeDataHeight) {
        return base;
    }

    for (let row = 0; row < baseHeight; row++) {
        base[row].push.apply(base[row], mergeData[row].map((ele) => ele));
    }
    return base;
}

},{}],4:[function(require,module,exports){
'use strict';

/**
 * Constructs an object storing rational numbers and methods performing operations
 * 
 * @param num numerator of the rational number
 * @param den denomenator of the rational number
 * @returns Object storing the rational number and method doing arthmetic operations
 */
function rational(num, den) {
  den = den || 1;
  if (Math.sign(den) === -1) {
    num = -num;
    den = -den;
  }
  return {
    num: num,
    den: den,
    add: (op) => rational(num * op.den + den * op.num, den * op.den),
    sub: (op) => rational(num * op.den - den * op.num, den * op.den),
    mul: (op) => multiply(op, num, den),
    div: (op) => {
      let _num = op.den;
      let _den = op.num;
      return multiply(rational(_num, _den), num, den);
    }
  }
}

module.exports = rational;

/**
 * Multiplies two rational number based on multiplication rules that cancels common terms
 * 
 * @param op the second operand
 * @param num numerator of first operand
 * @param den denominator of second operand
 * @returns another rational number
 */
function multiply(op, num, den) {
  let _num = Math.sign(num) * Math.sign(op.num);
  let _den = Math.sign(den) * Math.sign(op.den);
  if (Math.abs(num) === Math.abs(op.den) && Math.abs(den) === Math.abs(op.num)) {
    _num = _num;
    _den = _den;
  } else if (Math.abs(den) === Math.abs(op.num)) {
    _num = _num * Math.abs(num);
    _den = _den * Math.abs(op.den);
  } else if (Math.abs(num) === Math.abs(op.den)) {
    _num = _num * Math.abs(op.num);
    _den = _den * Math.abs(den);
  } else {
    _num = num * op.num;
    _den = den * op.den;
  }
  return rational(_num, _den);
}

},{}],5:[function(require,module,exports){
var matrix = require('matrix-js');
let data = [];

if (nodeRun()) {
  data = require('../data.json');
  expRegression(data, 4);
} else {
  window.expRegression = expRegression;
}

function expRegression(data, iteration = 10) {
  
  let minY = data[0].y;
  let maxY = data[data.length - 1].y;
  let b = [minY, maxY - minY, 20];
  if (nodeRun()) {
    console.log(b);
  }
  
  for (let i = 0; i < iteration; i++) {
    let dB = iterate(b, data);
    for (let index = 0; index < b.length; index++) {
      b[index] += dB[index];
    }
    if (nodeRun()) {
      console.log(paramsToString(b) + ' ' + paramsToString(dB, 6));
    }
  }
  
  return b; 
}

function iterate(b, data) {
  const jacob = [];
  const dy = [];
  
  data.forEach(element => {
    jacob.push(Jacob(element.x, b));
    dy.push(Y(element.x, element.y, b));
  });

  const J = matrix(jacob);
  const JT = matrix(J.trans());
  const A = matrix(JT.prod(J));
  const AInv = matrix(A.inv());

  const DYT = matrix(matrix([dy]).trans());
  const JY = matrix(JT.prod(DYT));

  const dB = AInv.prod(JY);
  
  return matrix(dB).trans()[0];
}


function Jacob(x, b ) {
  const jacob = [];
  const exp = Math.exp(-x / b[2]);
  jacob.push(1);
  jacob.push(1-exp);
  jacob.push(-(b[1]*x*exp)/(b[2]*b[2]));
  return jacob;
}

function f(x, b) {
  const exp = Math.exp(-x / b[2]);
  return b[0] + (b[1] * (1 - exp)); 
}

function Y(x, y, b) {
  const dy = [];
  return(y - f(x, b));
}

function nodeRun() { return (typeof window === 'undefined') };

function paramsToString(b, decimal = 3) {
  let out = '[';
  b.forEach((element, index) => {
    out += element.toFixed(decimal);
    if (index < b.length - 1) {
      out += ', ';
    }
  });
  out += ']';
  return out;
}
},{"../data.json":1,"matrix-js":2}]},{},[5]);
